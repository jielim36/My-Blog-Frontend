{"ast":null,"code":"/**\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('./types.js').Enter} Enter\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').Join} Join\n * @typedef {import('./types.js').FlowParents} FlowParents\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').PhrasingParents} PhrasingParents\n * @typedef {import('./types.js').SafeConfig} SafeConfig\n * @typedef {import('./types.js').State} State\n * @typedef {import('./types.js').TrackFields} TrackFields\n */\n\nimport { zwitch } from 'zwitch';\nimport { configure } from './configure.js';\nimport { handle as handlers } from './handle/index.js';\nimport { join } from './join.js';\nimport { unsafe } from './unsafe.js';\nimport { association } from './util/association.js';\nimport { compilePattern } from './util/compile-pattern.js';\nimport { containerPhrasing } from './util/container-phrasing.js';\nimport { containerFlow } from './util/container-flow.js';\nimport { indentLines } from './util/indent-lines.js';\nimport { safe } from './util/safe.js';\nimport { track } from './util/track.js';\n\n/**\n * Turn an mdast syntax tree into markdown.\n *\n * @param {Nodes} tree\n *   Tree to serialize.\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized markdown representing `tree`.\n */\nexport function toMarkdown(tree, options = {}) {\n  /** @type {State} */\n  const state = {\n    enter,\n    indentLines,\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    compilePattern,\n    safe: safeBound,\n    stack: [],\n    unsafe: [...unsafe],\n    join: [...join],\n    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined\n    // here.\n    handlers: {\n      ...handlers\n    },\n    options: {},\n    indexStack: [],\n    // @ts-expect-error: add `handle` in a second.\n    handle: undefined\n  };\n  configure(state, options);\n  if (state.options.tightDefinitions) {\n    state.join.push(joinDefinition);\n  }\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  });\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {\n      line: 1,\n      column: 1\n    },\n    lineShift: 0\n  });\n  if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {\n    result += '\\n';\n  }\n  return result;\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name);\n    return exit;\n\n    /**\n     * @returns {undefined}\n     */\n    function exit() {\n      state.stack.pop();\n    }\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node');\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction unknown(value) {\n  // Always a node.\n  const node = /** @type {Nodes} */value;\n  throw new Error('Cannot handle unknown node `' + node.type + '`');\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0;\n  }\n}\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {PhrasingParents} parent\n *   Parent of flow nodes.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info);\n}\n\n/**\n * Serialize the children of a parent that contains flow children.\n *\n * These children will typically be joined by blank lines.\n * What they are joined by exactly is defined by `Join` functions.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {FlowParents} parent\n *   Parent of flow nodes.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info);\n}\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} value\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config);\n}","map":{"version":3,"names":["zwitch","configure","handle","handlers","join","unsafe","association","compilePattern","containerPhrasing","containerFlow","indentLines","safe","track","toMarkdown","tree","options","state","enter","associationId","containerPhrasingBound","containerFlowBound","createTracker","safeBound","stack","indexStack","undefined","tightDefinitions","push","joinDefinition","invalid","unknown","result","before","after","now","line","column","lineShift","charCodeAt","length","name","exit","pop","value","Error","node","type","left","right","parent","info","config"],"sources":["C:/Users/jieli/Desktop/Coding/Project/MyBlog/Frontend/my-blog/node_modules/mdast-util-to-markdown/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('./types.js').Enter} Enter\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').Join} Join\n * @typedef {import('./types.js').FlowParents} FlowParents\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').PhrasingParents} PhrasingParents\n * @typedef {import('./types.js').SafeConfig} SafeConfig\n * @typedef {import('./types.js').State} State\n * @typedef {import('./types.js').TrackFields} TrackFields\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle as handlers} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\nimport {association} from './util/association.js'\nimport {compilePattern} from './util/compile-pattern.js'\nimport {containerPhrasing} from './util/container-phrasing.js'\nimport {containerFlow} from './util/container-flow.js'\nimport {indentLines} from './util/indent-lines.js'\nimport {safe} from './util/safe.js'\nimport {track} from './util/track.js'\n\n/**\n * Turn an mdast syntax tree into markdown.\n *\n * @param {Nodes} tree\n *   Tree to serialize.\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized markdown representing `tree`.\n */\nexport function toMarkdown(tree, options = {}) {\n  /** @type {State} */\n  const state = {\n    enter,\n    indentLines,\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    compilePattern,\n    safe: safeBound,\n    stack: [],\n    unsafe: [...unsafe],\n    join: [...join],\n    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined\n    // here.\n    handlers: {...handlers},\n    options: {},\n    indexStack: [],\n    // @ts-expect-error: add `handle` in a second.\n    handle: undefined\n  }\n\n  configure(state, options)\n\n  if (state.options.tightDefinitions) {\n    state.join.push(joinDefinition)\n  }\n\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  })\n\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name)\n    return exit\n\n    /**\n     * @returns {undefined}\n     */\n    function exit() {\n      state.stack.pop()\n    }\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction unknown(value) {\n  // Always a node.\n  const node = /** @type {Nodes} */ (value)\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {PhrasingParents} parent\n *   Parent of flow nodes.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info)\n}\n\n/**\n * Serialize the children of a parent that contains flow children.\n *\n * These children will typically be joined by blank lines.\n * What they are joined by exactly is defined by `Join` functions.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {FlowParents} parent\n *   Parent of flow nodes.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info)\n}\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} value\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}