{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n/**\n * @typedef {'center' | 'left' | 'none' | 'right'} Align\n */\n\nimport { ok as assert } from 'devlop';\n\n/**\n * Figure out the alignment of a GFM table.\n *\n * @param {Readonly<Array<Event>>} events\n *   List of events.\n * @param {number} index\n *   Table enter event.\n * @returns {Array<Align>}\n *   List of aligns.\n */\nexport function gfmTableAlign(events, index) {\n  assert(events[index][1].type === 'table', 'expected table');\n  let inDelimiterRow = false;\n  /** @type {Array<Align>} */\n  const align = [];\n  while (index < events.length) {\n    const event = events[index];\n    if (inDelimiterRow) {\n      if (event[0] === 'enter') {\n        // Start of alignment value: set a new column.\n        // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n        if (event[1].type === 'tableContent') {\n          align.push(events[index + 1][1].type === 'tableDelimiterMarker' ? 'left' : 'none');\n        }\n      }\n      // Exits:\n      // End of alignment value: change the column.\n      // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n      else if (event[1].type === 'tableContent') {\n        if (events[index - 1][1].type === 'tableDelimiterMarker') {\n          const alignIndex = align.length - 1;\n          align[alignIndex] = align[alignIndex] === 'left' ? 'center' : 'right';\n        }\n      }\n      // Done!\n      else if (event[1].type === 'tableDelimiterRow') {\n        break;\n      }\n    } else if (event[0] === 'enter' && event[1].type === 'tableDelimiterRow') {\n      inDelimiterRow = true;\n    }\n    index += 1;\n  }\n  return align;\n}","map":{"version":3,"names":["ok","assert","gfmTableAlign","events","index","type","inDelimiterRow","align","length","event","push","alignIndex"],"sources":["C:/Users/jieli/Desktop/Coding/Project/MyBlog/Frontend/my-blog/node_modules/micromark-extension-gfm-table/dev/lib/infer.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n/**\n * @typedef {'center' | 'left' | 'none' | 'right'} Align\n */\n\nimport {ok as assert} from 'devlop'\n\n/**\n * Figure out the alignment of a GFM table.\n *\n * @param {Readonly<Array<Event>>} events\n *   List of events.\n * @param {number} index\n *   Table enter event.\n * @returns {Array<Align>}\n *   List of aligns.\n */\nexport function gfmTableAlign(events, index) {\n  assert(events[index][1].type === 'table', 'expected table')\n  let inDelimiterRow = false\n  /** @type {Array<Align>} */\n  const align = []\n\n  while (index < events.length) {\n    const event = events[index]\n\n    if (inDelimiterRow) {\n      if (event[0] === 'enter') {\n        // Start of alignment value: set a new column.\n        // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n        if (event[1].type === 'tableContent') {\n          align.push(\n            events[index + 1][1].type === 'tableDelimiterMarker'\n              ? 'left'\n              : 'none'\n          )\n        }\n      }\n      // Exits:\n      // End of alignment value: change the column.\n      // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n      else if (event[1].type === 'tableContent') {\n        if (events[index - 1][1].type === 'tableDelimiterMarker') {\n          const alignIndex = align.length - 1\n\n          align[alignIndex] = align[alignIndex] === 'left' ? 'center' : 'right'\n        }\n      }\n      // Done!\n      else if (event[1].type === 'tableDelimiterRow') {\n        break\n      }\n    } else if (event[0] === 'enter' && event[1].type === 'tableDelimiterRow') {\n      inDelimiterRow = true\n    }\n\n    index += 1\n  }\n\n  return align\n}\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAAQA,EAAE,IAAIC,MAAM,QAAO,QAAQ;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAACC,MAAM,EAAEC,KAAK,EAAE;EAC3CH,MAAM,CAACE,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,KAAK,OAAO,EAAE,gBAAgB,CAAC;EAC3D,IAAIC,cAAc,GAAG,KAAK;EAC1B;EACA,MAAMC,KAAK,GAAG,EAAE;EAEhB,OAAOH,KAAK,GAAGD,MAAM,CAACK,MAAM,EAAE;IAC5B,MAAMC,KAAK,GAAGN,MAAM,CAACC,KAAK,CAAC;IAE3B,IAAIE,cAAc,EAAE;MAClB,IAAIG,KAAK,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;QACxB;QACA;QACA,IAAIA,KAAK,CAAC,CAAC,CAAC,CAACJ,IAAI,KAAK,cAAc,EAAE;UACpCE,KAAK,CAACG,IAAI,CACRP,MAAM,CAACC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,KAAK,sBAAsB,GAChD,MAAM,GACN,MACN,CAAC;QACH;MACF;MACA;MACA;MACA;MAAA,KACK,IAAII,KAAK,CAAC,CAAC,CAAC,CAACJ,IAAI,KAAK,cAAc,EAAE;QACzC,IAAIF,MAAM,CAACC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,KAAK,sBAAsB,EAAE;UACxD,MAAMM,UAAU,GAAGJ,KAAK,CAACC,MAAM,GAAG,CAAC;UAEnCD,KAAK,CAACI,UAAU,CAAC,GAAGJ,KAAK,CAACI,UAAU,CAAC,KAAK,MAAM,GAAG,QAAQ,GAAG,OAAO;QACvE;MACF;MACA;MAAA,KACK,IAAIF,KAAK,CAAC,CAAC,CAAC,CAACJ,IAAI,KAAK,mBAAmB,EAAE;QAC9C;MACF;IACF,CAAC,MAAM,IAAII,KAAK,CAAC,CAAC,CAAC,KAAK,OAAO,IAAIA,KAAK,CAAC,CAAC,CAAC,CAACJ,IAAI,KAAK,mBAAmB,EAAE;MACxEC,cAAc,GAAG,IAAI;IACvB;IAEAF,KAAK,IAAI,CAAC;EACZ;EAEA,OAAOG,KAAK;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}